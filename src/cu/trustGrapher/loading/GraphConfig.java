////////////////////////////////Algorithm//////////////////////////////////
package cu.trustGrapher.loading;

import cu.repsystestbed.algorithms.ReputationAlgorithm;
import cu.repsystestbed.algorithms.TrustAlgorithm;
import java.io.File;

import aohara.utilities.MyClassLoader;
import aohara.utilities.PropertyManager;

/**
 * Contains all of the configurations for a graph.  Instances of this class are used to create the GraphViewers and graphs.
 * GraphConfigs are generated by the AlgorithmLoader when a graph is added.
 * @author Andrew O'Hara
 */
public class GraphConfig {

    public static String NO_BASE = "noBase", NO_CONFIG = "noConfig", NO_CLASS = "noClass";
    private File classFile;
    private int index, base, classIndex;
    private boolean display;
    protected Object algorithm;
    protected PropertyManager properties;

//////////////////////////////////Constructor///////////////////////////////////
    /**
     * Creates a new GraphConfig.
     * @param index The index for the GraphConfig automatically assigned by the AlgorithmLoader
     * @param display Whether or not the graphPair is to be shown in the simulator
     * @param base The index of the graphConfig that this graph depends on
     * @param classpath The path to the algorithm class that this graph will use.  The feedbackHistory is set to NO_CLASS
     * @param propertyFile The optional property file that contains the configurations for this algorithm
     */
    public GraphConfig(int index, boolean display, int base, int classIndex, String classPath, File propertyFile){
        this.index = index;
        this.display = display;
        this.base = base;
        this.classIndex = classIndex;
        setProperties(propertyFile);
        if (classPath != null){
            classFile = new File(classPath);
            algorithm = newAlgorithm(classPath);
        }else{
            classFile = null;
            algorithm = null;
        }
    }
//////////////////////////////////Accessors/////////////////////////////////////

    /**
     * Returns the string representation of this GraphConfig that is saved the the properties file.
     * This String can then be used to create an equivalent GraphConfig.
     * @return the string representation to save as a property
     */
    @Override
    public String toString() {
        String baseString = (base != -1) ? "" + base : NO_BASE;
        String  classString = (classIndex != -1) ? "" + classIndex : NO_CLASS;
        String configString = (properties != null) ? properties.getPropertyFile().getPath() : NO_CONFIG;
        return display + "," + baseString + "," + classString + "," + configString;
    }

    /**
     * @return the index
     */
    public int getIndex() {
        return index;
    }
    
    public String getKey(){
        return AlgorithmLoader.GRAPH + index;
    }

    /**
     * @return the index of the graph that this graph depends on
     */
    public int getBaseIndex() {
        return base;
    }

    /**
     * @return the classFile that this graph will use in the simulation
     */
    public File getClassFile() {
        return classFile;
    }

    /**
     * @return the diaplay name of this graph
     */
    public String getDisplayName() {
        return index + "-" + ( (algorithm != null) ? algorithm.getClass().getSimpleName() : "FeedbackHistory" );
    }

    /**
     * @return Whether this graph will be shown in the Simulator
     */
    public boolean isDisplayed() {
        return display;
    }

    /**
     * @return The algorithm attached to this GraphConfig
     */
    public Object getAlgorithm(){
        return algorithm;
    }

    /**
     * @return The optional properties file for the algorithm
     */
    public File getProperties(){
        return (properties != null) ?properties.getPropertyFile() : null;
    }

    /**
     * @return Whether or not the GraphPair represented by this is the FeedbackHistory Graph
     */
    public boolean isFeedbackGraph(){
        return algorithm == null;
    }

    /**
     * @return Whether or not the attached algorithm is a ReputationAlgortihm
     */
    public boolean isReputationGraph(){
        return algorithm instanceof ReputationAlgorithm;
    }

    /**
     * @return Whether or not the attached algorithm is a TrustAlgortihm
     */
    public boolean isTrustGraph(){
        return algorithm instanceof TrustAlgorithm;
    }
    
///////////////////////////////////Methods//////////////////////////////////////
    
    /**
     * @param baseIndex The new index of the graph that this graph will depend on
     */
    public void setBase(int base) {
        this.base = base;
    }

    /**
     * @param propertyFile the configFile to set
     */
    public final void setProperties(File propertyFile) {
        if (propertyFile == null){
            properties= null;
        }else{
            properties = (propertyFile.exists()) ? new PropertyManager(propertyFile) : null;
        }
    }

    /**
     * @param display Whether or not the graph represented by this will be displayed in the Simulator
     */
    public void setDisplay(boolean display){
        this.display = display;
    }

////////////////////////////////Static Methods//////////////////////////////////
    /**
     *  Takes a path and tries to load an object from it.  If it is a valid algorithm, it returns it as an Object.
     * @param classPath The path to the algorithm class file
     * @return The algorithm as an Object
     */
    public static Object newAlgorithm(String classPath) {
        Object o = MyClassLoader.newClass(classPath);
        if ((o instanceof ReputationAlgorithm) || (o instanceof TrustAlgorithm) || classPath.endsWith(".jar")) {
            return o;
        }
        aohara.utilities.ChatterBox.error("TrustClassLoader", "newAlgorithm()", "The file was invalid, no longer exists, or is not a recognized algorithm.\n" + classPath);
        return null;
    }
}
////////////////////////////////////////////////////////////////////////////////
